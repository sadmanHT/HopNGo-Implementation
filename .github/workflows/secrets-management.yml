name: Secrets Management Setup

# This workflow demonstrates proper secrets management practices
# and can be used as a reference for other workflows

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to configure'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      dry_run:
        description: 'Dry run mode (no actual changes)'
        required: false
        default: true
        type: boolean

env:
  # Public configuration - safe to expose
  REGISTRY: ghcr.io
  IMAGE_PREFIX: hopngo
  
  # Environment-specific configurations
  STAGING_CLUSTER_NAME: hopngo-staging
  PRODUCTION_CLUSTER_NAME: hopngo-production
  
  # OIDC configuration
  OIDC_AUDIENCE: sts.amazonaws.com
  OIDC_ROLE_SESSION_NAME: GitHubActions

jobs:
  validate-secrets:
    name: Validate Secrets Configuration
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    permissions:
      id-token: write
      contents: read
      packages: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Validate required secrets
      run: |
        echo "üîç Validating secrets configuration for ${{ github.event.inputs.environment }}..."
        
        # List of required secrets for each environment
        case "${{ github.event.inputs.environment }}" in
          "staging")
            REQUIRED_SECRETS=(
              "STAGING_KUBECONFIG"
              "STAGING_DATABASE_URL"
              "STAGING_REDIS_URL"
              "STAGING_AWS_ROLE_ARN"
              "STAGING_NOTIFICATION_API_KEY"
            )
            ;;
          "production")
            REQUIRED_SECRETS=(
              "PRODUCTION_KUBECONFIG"
              "PRODUCTION_DATABASE_URL"
              "PRODUCTION_REDIS_URL"
              "PRODUCTION_AWS_ROLE_ARN"
              "PRODUCTION_NOTIFICATION_API_KEY"
              "PRODUCTION_MONITORING_TOKEN"
              "PRODUCTION_BACKUP_ENCRYPTION_KEY"
            )
            ;;
        esac
        
        # Check if secrets are available (without exposing values)
        MISSING_SECRETS=()
        for secret in "${REQUIRED_SECRETS[@]}"; do
          # Use indirect variable reference to check if secret exists
          if [ -z "${!secret:-}" ]; then
            MISSING_SECRETS+=("$secret")
          else
            echo "‚úÖ $secret is configured"
          fi
        done
        
        if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
          echo "‚ùå Missing required secrets:"
          printf '  - %s\n' "${MISSING_SECRETS[@]}"
          echo ""
          echo "Please configure these secrets in GitHub repository settings:"
          echo "Settings > Secrets and variables > Actions > Environment secrets"
          exit 1
        fi
        
        echo "‚úÖ All required secrets are configured"
      env:
        # Map GitHub secrets to environment variables for validation
        STAGING_KUBECONFIG: ${{ secrets.STAGING_KUBECONFIG }}
        STAGING_DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}
        STAGING_REDIS_URL: ${{ secrets.STAGING_REDIS_URL }}
        STAGING_AWS_ROLE_ARN: ${{ secrets.STAGING_AWS_ROLE_ARN }}
        STAGING_NOTIFICATION_API_KEY: ${{ secrets.STAGING_NOTIFICATION_API_KEY }}
        PRODUCTION_KUBECONFIG: ${{ secrets.PRODUCTION_KUBECONFIG }}
        PRODUCTION_DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
        PRODUCTION_REDIS_URL: ${{ secrets.PRODUCTION_REDIS_URL }}
        PRODUCTION_AWS_ROLE_ARN: ${{ secrets.PRODUCTION_AWS_ROLE_ARN }}
        PRODUCTION_NOTIFICATION_API_KEY: ${{ secrets.PRODUCTION_NOTIFICATION_API_KEY }}
        PRODUCTION_MONITORING_TOKEN: ${{ secrets.PRODUCTION_MONITORING_TOKEN }}
        PRODUCTION_BACKUP_ENCRYPTION_KEY: ${{ secrets.PRODUCTION_BACKUP_ENCRYPTION_KEY }}
        
    - name: Configure AWS credentials with OIDC
      if: github.event.inputs.environment == 'production'
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.PRODUCTION_AWS_ROLE_ARN }}
        role-session-name: ${{ env.OIDC_ROLE_SESSION_NAME }}
        aws-region: us-east-1
        audience: ${{ env.OIDC_AUDIENCE }}
        
    - name: Test AWS OIDC connection
      if: github.event.inputs.environment == 'production'
      run: |
        echo "üîê Testing AWS OIDC connection..."
        
        # Test AWS credentials without exposing sensitive information
        aws sts get-caller-identity --query 'Account' --output text > /dev/null
        if [ $? -eq 0 ]; then
          echo "‚úÖ AWS OIDC authentication successful"
          echo "Account: $(aws sts get-caller-identity --query 'Account' --output text)"
          echo "Role: $(aws sts get-caller-identity --query 'Arn' --output text | cut -d'/' -f2)"
        else
          echo "‚ùå AWS OIDC authentication failed"
          exit 1
        fi
        
    - name: Test Kubernetes connectivity
      run: |
        echo "üîß Testing Kubernetes connectivity..."
        
        # Configure kubectl based on environment
        case "${{ github.event.inputs.environment }}" in
          "staging")
            echo "${{ secrets.STAGING_KUBECONFIG }}" | base64 -d > kubeconfig
            NAMESPACE="hopngo-stg"
            ;;
          "production")
            echo "${{ secrets.PRODUCTION_KUBECONFIG }}" | base64 -d > kubeconfig
            NAMESPACE="hopngo-prod"
            ;;
        esac
        
        export KUBECONFIG=kubeconfig
        
        # Test cluster connectivity
        if kubectl cluster-info > /dev/null 2>&1; then
          echo "‚úÖ Kubernetes cluster connectivity successful"
          echo "Cluster: $(kubectl config current-context)"
          echo "Server: $(kubectl cluster-info | grep 'Kubernetes control plane' | awk '{print $NF}')"
        else
          echo "‚ùå Kubernetes cluster connectivity failed"
          exit 1
        fi
        
        # Test namespace access
        if kubectl get namespace "$NAMESPACE" > /dev/null 2>&1; then
          echo "‚úÖ Namespace '$NAMESPACE' is accessible"
        else
          echo "‚ö†Ô∏è Namespace '$NAMESPACE' is not accessible or doesn't exist"
        fi
        
        # Clean up kubeconfig
        rm -f kubeconfig
        
    - name: Validate secret rotation policy
      run: |
        echo "üîÑ Validating secret rotation policy..."
        
        # This is a demonstration of secret rotation validation
        # In practice, you would integrate with your secret management system
        
        cat << 'EOF'
        üìã Secret Rotation Policy Checklist:
        
        ‚úÖ Database credentials: Rotate every 90 days
        ‚úÖ API keys: Rotate every 60 days  
        ‚úÖ TLS certificates: Auto-renewal 30 days before expiry
        ‚úÖ Service account tokens: Rotate every 30 days
        ‚úÖ Encryption keys: Rotate every 180 days
        
        üîê Secret Management Best Practices:
        - Use environment-specific secrets
        - Enable secret scanning in repositories
        - Implement least-privilege access
        - Monitor secret usage and access
        - Use OIDC for cloud provider authentication
        - Mask sensitive values in logs
        EOF
        
  demonstrate-secure-usage:
    name: Demonstrate Secure Secret Usage
    runs-on: ubuntu-latest
    needs: validate-secrets
    environment: ${{ github.event.inputs.environment }}
    permissions:
      id-token: write
      contents: read
    
    steps:
    - name: Secure secret handling example
      run: |
        echo "üõ°Ô∏è Demonstrating secure secret handling..."
        
        # ‚úÖ GOOD: Use secrets in environment variables
        DATABASE_URL="${{ secrets.STAGING_DATABASE_URL }}"
        
        # ‚úÖ GOOD: Mask sensitive values in logs
        echo "::add-mask::$DATABASE_URL"
        
        # ‚úÖ GOOD: Extract only non-sensitive parts for logging
        DB_HOST=$(echo "$DATABASE_URL" | sed 's|.*@\([^:]*\):.*|\1|')
        echo "Connecting to database host: $DB_HOST"
        
        # ‚úÖ GOOD: Use temporary files with restricted permissions
        umask 077  # Ensure only owner can read/write
        echo "${{ secrets.STAGING_KUBECONFIG }}" | base64 -d > /tmp/kubeconfig
        
        # ‚úÖ GOOD: Clean up temporary files
        trap 'rm -f /tmp/kubeconfig' EXIT
        
        # ‚úÖ GOOD: Validate secret format before use
        if [[ "$DATABASE_URL" =~ ^postgresql://.*$ ]]; then
          echo "‚úÖ Database URL format is valid"
        else
          echo "‚ùå Invalid database URL format"
          exit 1
        fi
        
        echo "‚úÖ Secure secret handling demonstration completed"
        
    - name: Secret scanning simulation
      run: |
        echo "üîç Simulating secret scanning..."
        
        # Simulate common secret patterns that should be caught
        PATTERNS=(
          "password.*=.*[a-zA-Z0-9]{8,}"
          "api[_-]?key.*=.*[a-zA-Z0-9]{20,}"
          "secret.*=.*[a-zA-Z0-9]{16,}"
          "token.*=.*[a-zA-Z0-9]{20,}"
          "-----BEGIN.*PRIVATE KEY-----"
        )
        
        echo "Checking for common secret patterns in codebase..."
        
        # In a real scenario, this would scan actual files
        # Here we're just demonstrating the concept
        for pattern in "${PATTERNS[@]}"; do
          echo "  Scanning for pattern: ${pattern:0:20}..."
        done
        
        echo "‚úÖ Secret scanning simulation completed"
        echo "üí° Consider integrating tools like GitLeaks, TruffleHog, or GitHub Secret Scanning"
        
  security-recommendations:
    name: Security Recommendations
    runs-on: ubuntu-latest
    needs: [validate-secrets, demonstrate-secure-usage]
    if: always()
    
    steps:
    - name: Generate security recommendations
      run: |
        echo "üìã Security Recommendations Report" >> $GITHUB_STEP_SUMMARY
        echo "===================================" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "## ‚úÖ Implemented Security Measures" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment Separation**: Staging and production secrets are isolated" >> $GITHUB_STEP_SUMMARY
        echo "- **OIDC Integration**: Keyless authentication with cloud providers" >> $GITHUB_STEP_SUMMARY
        echo "- **Secret Masking**: Sensitive values are masked in workflow logs" >> $GITHUB_STEP_SUMMARY
        echo "- **Least Privilege**: Workflows only access required secrets" >> $GITHUB_STEP_SUMMARY
        echo "- **Temporary Files**: Secure handling of temporary credential files" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "## üîß Additional Recommendations" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Secret Management" >> $GITHUB_STEP_SUMMARY
        echo "- Implement automated secret rotation" >> $GITHUB_STEP_SUMMARY
        echo "- Use external secret management (AWS Secrets Manager, Azure Key Vault, etc.)" >> $GITHUB_STEP_SUMMARY
        echo "- Enable GitHub secret scanning alerts" >> $GITHUB_STEP_SUMMARY
        echo "- Regular secret audits and access reviews" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### Monitoring & Alerting" >> $GITHUB_STEP_SUMMARY
        echo "- Monitor secret access patterns" >> $GITHUB_STEP_SUMMARY
        echo "- Alert on unusual secret usage" >> $GITHUB_STEP_SUMMARY
        echo "- Track secret age and rotation status" >> $GITHUB_STEP_SUMMARY
        echo "- Implement break-glass procedures" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### Compliance" >> $GITHUB_STEP_SUMMARY
        echo "- Document secret handling procedures" >> $GITHUB_STEP_SUMMARY
        echo "- Regular security assessments" >> $GITHUB_STEP_SUMMARY
        echo "- Incident response procedures" >> $GITHUB_STEP_SUMMARY
        echo "- Staff security training" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Status summary
        if [ "${{ needs.validate-secrets.result }}" = "success" ] && [ "${{ needs.demonstrate-secure-usage.result }}" = "success" ]; then
          echo "## üéâ Overall Status: PASSED" >> $GITHUB_STEP_SUMMARY
          echo "Your secrets management configuration is properly set up and follows security best practices." >> $GITHUB_STEP_SUMMARY
        else
          echo "## ‚ö†Ô∏è Overall Status: NEEDS ATTENTION" >> $GITHUB_STEP_SUMMARY
          echo "Some issues were found in your secrets management configuration. Please review and address them." >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "---" >> $GITHUB_STEP_SUMMARY
        echo "*Generated on $(date -u '+%Y-%m-%d %H:%M:%S UTC')*" >> $GITHUB_STEP_SUMMARY