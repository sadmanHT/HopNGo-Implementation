#!/usr/bin/env node

import openapiTS from 'openapi-typescript';
import fs from 'fs-extra';
import path from 'path';
import chalk from 'chalk';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Service configuration
const services = [
  {
    name: 'auth-service',
    specPath: '../../docs/openapi/auth-service.json',
    outputDir: 'auth'
  },
  {
    name: 'social-service',
    specPath: '../../docs/openapi/social-service.json', 
    outputDir: 'social'
  },
  {
    name: 'booking-service',
    specPath: '../../docs/openapi/booking-service.json',
    outputDir: 'booking'
  },
  {
    name: 'chat-service',
    specPath: '../../docs/openapi/chat-service.json',
    outputDir: 'chat'
  },
  {
    name: 'market-service',
    specPath: '../../docs/openapi/market-service.json',
    outputDir: 'market'
  },
  {
    name: 'search-service',
    specPath: '../../docs/openapi/search-service.json',
    outputDir: 'search'
  },
  {
    name: 'ai-service',
    specPath: '../../docs/openapi/ai-service.json',
    outputDir: 'ai'
  },
  {
    name: 'trip-planning-service',
    specPath: '../../docs/openapi/trip-planning-service.json',
    outputDir: 'tripPlanning'
  },
  {
    name: 'admin-service',
    specPath: '../../docs/openapi/admin-service.json',
    outputDir: 'admin'
  },
  {
    name: 'analytics-service',
    specPath: '../../docs/openapi/analytics-service.json',
    outputDir: 'analytics'
  },
  {
    name: 'emergency-service',
    specPath: '../../docs/openapi/emergency-service.json',
    outputDir: 'emergency'
  }
];

// Output directory
const outputBaseDir = path.resolve(__dirname, '../../frontend/src/lib/sdk');

async function generateTypes(service) {
  try {
    console.log(chalk.blue(`üîß Generating types for ${service.name}...`));
    
    const specPath = path.resolve(__dirname, service.specPath);
    const outputDir = path.join(outputBaseDir, service.outputDir);
    
    // Ensure spec file exists
    if (!await fs.pathExists(specPath)) {
      throw new Error(`OpenAPI spec not found: ${specPath}`);
    }
    
    // Generate TypeScript types
    const output = await openapiTS(specPath, {
      transform: {
        // Transform operation names to camelCase
        operationId: (operationId) => {
          return operationId.replace(/[_-](.)/g, (_, char) => char.toUpperCase());
        }
      },
      exportType: true,
      immutableTypes: true,
      additionalProperties: false,
      defaultNonNullable: true
    });
    
    // Ensure output directory exists
    await fs.ensureDir(outputDir);
    
    // Write types file
    const typesPath = path.join(outputDir, 'types.ts');
    await fs.writeFile(typesPath, output);
    
    console.log(chalk.green(`‚úÖ Generated types: ${typesPath}`));
    return { service: service.name, success: true, typesPath };
    
  } catch (error) {
    console.log(chalk.red(`‚ùå Failed to generate types for ${service.name}: ${error.message}`));
    return { service: service.name, success: false, error: error.message };
  }
}

async function generateClient(service) {
  try {
    console.log(chalk.blue(`üîß Generating client for ${service.name}...`));
    
    const outputDir = path.join(outputBaseDir, service.outputDir);
    const clientPath = path.join(outputDir, 'client.ts');
    
    // Read the OpenAPI spec to extract service info
    const specPath = path.resolve(__dirname, service.specPath);
    const spec = await fs.readJson(specPath);
    
    const serviceTitle = spec.info?.title || `${service.name} API`;
    const serviceVersion = spec.info?.version || '1.0.0';
    const baseUrl = spec.servers?.[0]?.url || `http://localhost:8080/api/v1/${service.outputDir}`;
    
    const clientCode = `/**
 * ${serviceTitle}
 * Version: ${serviceVersion}
 * 
 * Auto-generated TypeScript client
 * Do not edit this file manually
 */

import type { paths } from './types';

export interface ApiClientConfig {
  baseUrl?: string;
  headers?: Record<string, string>;
  timeout?: number;
}

export interface ApiResponse<T> {
  data: T;
  status: number;
  statusText: string;
  headers: Record<string, string>;
}

export interface ApiError {
  message: string;
  status: number;
  statusText: string;
  data?: any;
}

export class ${service.name.split('-').map(part => 
  part.charAt(0).toUpperCase() + part.slice(1)
).join('')}Client {
  private baseUrl: string;
  private defaultHeaders: Record<string, string>;
  private timeout: number;

  constructor(config: ApiClientConfig = {}) {
    this.baseUrl = config.baseUrl || '${baseUrl}';
    this.defaultHeaders = {
      'Content-Type': 'application/json',
      ...config.headers
    };
    this.timeout = config.timeout || 10000;
  }

  private async request<T>(
    method: string,
    path: string,
    options: {
      params?: Record<string, any>;
      body?: any;
      headers?: Record<string, string>;
    } = {}
  ): Promise<ApiResponse<T>> {
    const url = new URL(path, this.baseUrl);
    
    // Add query parameters
    if (options.params) {
      Object.entries(options.params).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          url.searchParams.append(key, String(value));
        }
      });
    }

    const headers = {
      ...this.defaultHeaders,
      ...options.headers
    };

    const requestInit: RequestInit = {
      method,
      headers,
      signal: AbortSignal.timeout(this.timeout)
    };

    if (options.body && method !== 'GET' && method !== 'HEAD') {
      requestInit.body = typeof options.body === 'string' 
        ? options.body 
        : JSON.stringify(options.body);
    }

    try {
      const response = await fetch(url.toString(), requestInit);
      
      let data: T;
      const contentType = response.headers.get('content-type');
      
      if (contentType?.includes('application/json')) {
        data = await response.json();
      } else {
        data = await response.text() as unknown as T;
      }

      if (!response.ok) {
        const error: ApiError = {
          message: response.statusText,
          status: response.status,
          statusText: response.statusText,
          data
        };
        throw error;
      }

      return {
        data,
        status: response.status,
        statusText: response.statusText,
        headers: Object.fromEntries(response.headers.entries())
      };
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        throw new Error('Request timeout');
      }
      throw error;
    }
  }

  // Convenience methods for common HTTP verbs
  async get<T>(path: string, options?: { params?: Record<string, any>; headers?: Record<string, string> }) {
    return this.request<T>('GET', path, options);
  }

  async post<T>(path: string, body?: any, options?: { params?: Record<string, any>; headers?: Record<string, string> }) {
    return this.request<T>('POST', path, { ...options, body });
  }

  async put<T>(path: string, body?: any, options?: { params?: Record<string, any>; headers?: Record<string, string> }) {
    return this.request<T>('PUT', path, { ...options, body });
  }

  async patch<T>(path: string, body?: any, options?: { params?: Record<string, any>; headers?: Record<string, string> }) {
    return this.request<T>('PATCH', path, { ...options, body });
  }

  async delete<T>(path: string, options?: { params?: Record<string, any>; headers?: Record<string, string> }) {
    return this.request<T>('DELETE', path, options);
  }

  // Set authentication token
  setAuthToken(token: string) {
    this.defaultHeaders['Authorization'] = \`Bearer \${token}\`;
  }

  // Remove authentication token
  clearAuthToken() {
    delete this.defaultHeaders['Authorization'];
  }

  // Update base URL
  setBaseUrl(baseUrl: string) {
    this.baseUrl = baseUrl;
  }

  // Update default headers
  setHeaders(headers: Record<string, string>) {
    this.defaultHeaders = { ...this.defaultHeaders, ...headers };
  }
}

// Export type helpers
export type Paths = paths;

// Create default client instance
export const ${service.outputDir}Client = new ${service.name.split('-').map(part => 
  part.charAt(0).toUpperCase() + part.slice(1)
).join('')}Client();

export default ${service.outputDir}Client;
`;
    
    await fs.writeFile(clientPath, clientCode);
    console.log(chalk.green(`‚úÖ Generated client: ${clientPath}`));
    
    return { service: service.name, success: true, clientPath };
    
  } catch (error) {
    console.log(chalk.red(`‚ùå Failed to generate client for ${service.name}: ${error.message}`));
    return { service: service.name, success: false, error: error.message };
  }
}

async function generateIndexFile() {
  try {
    const indexPath = path.join(outputBaseDir, 'index.ts');
    
    const indexContent = `/**
 * HopNGo SDK
 * 
 * Auto-generated TypeScript clients for all HopNGo services
 * Do not edit this file manually
 */

// Export all service clients
export { AuthServiceClient, authClient } from './auth/client';
export { SocialServiceClient, socialClient } from './social/client';
export { BookingServiceClient, bookingClient } from './booking/client';
export { ChatServiceClient, chatClient } from './chat/client';
export { MarketServiceClient, marketClient } from './market/client';
export { SearchServiceClient, searchClient } from './search/client';
export { AiServiceClient, aiClient } from './ai/client';
export { TripPlanningServiceClient, tripPlanningClient } from './tripPlanning/client';
export { AdminServiceClient, adminClient } from './admin/client';
export { AnalyticsServiceClient, analyticsClient } from './analytics/client';
export { EmergencyServiceClient, emergencyClient } from './emergency/client';

// Export all types
export type { Paths as AuthPaths } from './auth/types';
export type { Paths as SocialPaths } from './social/types';
export type { Paths as BookingPaths } from './booking/types';
export type { Paths as ChatPaths } from './chat/types';
export type { Paths as MarketPaths } from './market/types';
export type { Paths as SearchPaths } from './search/types';
export type { Paths as AiPaths } from './ai/types';
export type { Paths as TripPlanningPaths } from './tripPlanning/types';
export type { Paths as AdminPaths } from './admin/types';
export type { Paths as AnalyticsPaths } from './analytics/types';
export type { Paths as EmergencyPaths } from './emergency/types';

// Export common types
export type { ApiClientConfig, ApiResponse, ApiError } from './auth/client';

// Create a unified SDK object
import { authClient } from './auth/client';
import { socialClient } from './social/client';
import { bookingClient } from './booking/client';
import { chatClient } from './chat/client';
import { marketClient } from './market/client';
import { searchClient } from './search/client';
import { aiClient } from './ai/client';
import { tripPlanningClient } from './tripPlanning/client';
import { adminClient } from './admin/client';
import { analyticsClient } from './analytics/client';
import { emergencyClient } from './emergency/client';

export const HopNGoSDK = {
  auth: authClient,
  social: socialClient,
  booking: bookingClient,
  chat: chatClient,
  market: marketClient,
  search: searchClient,
  ai: aiClient,
  tripPlanning: tripPlanningClient,
  admin: adminClient,
  analytics: analyticsClient,
  emergency: emergencyClient,
  
  // Set auth token for all clients
  setAuthToken(token: string) {
    this.auth.setAuthToken(token);
    this.social.setAuthToken(token);
    this.booking.setAuthToken(token);
    this.chat.setAuthToken(token);
    this.market.setAuthToken(token);
    this.search.setAuthToken(token);
    this.ai.setAuthToken(token);
    this.tripPlanning.setAuthToken(token);
    this.admin.setAuthToken(token);
    this.analytics.setAuthToken(token);
    this.emergency.setAuthToken(token);
  },
  
  // Clear auth token from all clients
  clearAuthToken() {
    this.auth.clearAuthToken();
    this.social.clearAuthToken();
    this.booking.clearAuthToken();
    this.chat.clearAuthToken();
    this.market.clearAuthToken();
    this.search.clearAuthToken();
    this.ai.clearAuthToken();
    this.tripPlanning.clearAuthToken();
    this.admin.clearAuthToken();
    this.analytics.clearAuthToken();
    this.emergency.clearAuthToken();
  }
};

export default HopNGoSDK;
`;
    
    await fs.writeFile(indexPath, indexContent);
    console.log(chalk.green(`üìù Generated SDK index: ${indexPath}`));
    
  } catch (error) {
    console.log(chalk.red(`‚ùå Failed to generate index file: ${error.message}`));
  }
}

async function main() {
  console.log(chalk.cyan('üöÄ HopNGo SDK Generator'));
  console.log(chalk.cyan('========================'));
  
  // Ensure output directory exists
  await fs.ensureDir(outputBaseDir);
  console.log(chalk.blue(`üìÅ Output directory: ${outputBaseDir}`));
  
  const results = [];
  
  // Generate types and clients for all services
  for (const service of services) {
    const typesResult = await generateTypes(service);
    results.push(typesResult);
    
    if (typesResult.success) {
      const clientResult = await generateClient(service);
      results.push(clientResult);
    }
  }
  
  // Generate index file
  await generateIndexFile();
  
  // Summary
  console.log(chalk.cyan('\nüìä Summary:'));
  const serviceResults = results.filter((_, index) => index % 2 === 0); // Only type generation results
  serviceResults.forEach(result => {
    const status = result.success ? chalk.green('‚úÖ') : chalk.red('‚ùå');
    console.log(`${status} ${result.service}: ${result.success ? 'Generated' : result.error}`);
  });
  
  const successCount = serviceResults.filter(r => r.success).length;
  console.log(chalk.cyan(`\nüéâ Generated SDKs for ${successCount}/${services.length} services!`));
  
  if (successCount > 0) {
    console.log(chalk.green('\nüí° Usage example:'));
    console.log(chalk.gray('import { HopNGoSDK } from "./lib/sdk";'));
    console.log(chalk.gray(''));
    console.log(chalk.gray('// Set auth token'));
    console.log(chalk.gray('HopNGoSDK.setAuthToken("your-jwt-token");'));
    console.log(chalk.gray(''));
    console.log(chalk.gray('// Use the APIs'));
    console.log(chalk.gray('const user = await HopNGoSDK.auth.get("/users/me");'));
    console.log(chalk.gray('const posts = await HopNGoSDK.social.get("/posts");'));
  }
}

// Handle errors gracefully
process.on('unhandledRejection', (error) => {
  console.error(chalk.red('‚ùå Unhandled error:'), error);
  process.exit(1);
});

// Run the generator
main().catch(error => {
  console.error(chalk.red('‚ùå Failed to generate SDKs:'), error);
  process.exit(1);
});